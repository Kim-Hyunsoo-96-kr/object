# 객체지향 프로그래밍
---
* 진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.
* 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라
  * 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다. 따라서 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.
* 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협략하는 공동체의 일원으로 봐야 한다.
  * 객체를 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만든다.
  * 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현하라
  * 훌륭한 협력이 훌륭항 객체를 낳고, 훌륭한 객체가 훌륭한 클래스를 낳는다.
* 도메인 : 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
* 일반적으로 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야 한다.
* 클래스 사이의 관계도 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어서 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다.
* 클래스의 외부와 내부를 구분하는 이유는 경계의 명확성이 객체의 자율서을 보장하기 때문이다.
* 객체는 상태와 행동을 함께 가지는 복합적인 존재이다.
* 객체는 스스로 판단하고 행동하는 자율적인 존재이다.
* 1장에서는 금액을 구현하기 위해 Long 타입을 사용했다
* Long 타입은 변수의 크기나 연산자의 종류와 관련된 구현 관점의 제약은 표형할 수 있지만 Money타입처럼 저장하는 값이 금액과 관련돼 있다는 의미를 전달할 수는 없다.
* 또한 금액과 관련된 로직이 서로 다른 곳에 중복되어 구현되는 것을 막을 수 없다.
* 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫걸음이다.
* 객체는 다른 객체의 인터페이스에 곤개된 행동을 수행하도록 요청(request)할 수 있다. 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답(response)한다.
* 객체가 다른 객체와 상호작용 할 수 있는 유일한 방법은 메시지를 전송 하는 것뿐이다.
* 다른 객체에게 요청이 도착할 때 해당 객체가 메시지를 수신했다고 이야기 한다.
* 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정한다.
* 이처럼 수신된 메시지를 처리하기 위한 자신만의 방법을 메서드라고 부른다.
* 메시지와 메서드의 구분에서부터 다형성(polymorphism)의 개념이 출발한다.
* 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 채턴을 TEMPLATE METHOD 패턴이라 한다.
* 코드의 의존성과 실행 시점의 의존성이 다를 수 있다.
* 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다.
* 반연 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다
* 울륭한 객체지향 설계자로 성장하기 위해서는 항상 유연성과 가독성 사이에서 고민해야 한다.
* 차이에 의한 프로그래밍 : 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법
* 상속이 가치있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다.
* 인터페이스 : 객체가 이해할 수 있는 메시지의 목록을 정의하는 것
* 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있기 때문에 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있다.
* 업캐스팅(upcasting) : 자식 클래스가 부모 클래스를 대신하는 것
* 메시지와 메서드는 다른 개념이다.
* Movie는 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다. 이를 다형성이라 한다.
* 다형성은 컴파일 타임과 런타임 의존성이 다를 수 있다는 사실을 기반으로 한다.
* 다형성이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.
* 따라서 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다.(인터페이스가 동일해야한다.)
* AmountDiscountPolicy, PercentDiscountPolicy가 다형적인 협력에 참여할 수 있는 이유는 이들이 DiscountPolicy로부터 동일한 인터페이스를 물려받았기 때문이다.
* 이 두 클래스의 인터페이스를 통일하기 위해 사용된 방법이 상속인것이다.
* 메시지와 메서드를 런타임에 바인딩한다. 이를 지연 바인딩(lazy binding), 또는 동적 바인딩(dynamic binding)이라 한다.
* 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 초기 바인딩(early binding), 또는 정적 바인딩(static binding)이라고 부른다.
* 상속에는 구현 상속(클래스 상속)과 인터페이스 상속으로 분류할 수 있다.
* 구현 상속을 서브클래싱(subclassing)이라 부르고, 인터페이스 상속을 서브타이핑(subtyping)이라 부른다.
* 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 한다. (코드 재사용을 위한 상속은 지양 -> 변경에 취약한 코드를 생성)
* 추상화의 장점
  1. 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다는 것
  2. 추상화를 이용하면 설계가 좀 더 유연해진다는 것
* 유연성이 필요한 곳에 추상화를 사용하라
* 상속은 캡슐화를 위반하고 설계의 유연성을 떨어뜨린다.
* 